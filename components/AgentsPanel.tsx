import React, { useState, useEffect, useRef, useCallback } from 'react';
import { chatWithAgent, refineCodeWithAgent, getAiHint } from '../services/geminiService';
import type { FileSystemState, ChatMessage, DraggableComponent, AjaxTemplate, SavedUrl } from '../types';
import { SpinnerIcon, PanelLeftIcon, PanelRightIcon, MagicWandIcon, LightbulbIcon, XIcon, MaximizeIcon, MinimizeIcon, ChevronDownIcon, ChevronUpIcon, CogIcon, RefreshCwIcon, GlobeIcon, CodeIcon } from './Icons';
import CollapsibleSection from './CollapsibleSection';
import ChatMessageView from './ChatMessage';
import FileExplorer from './FileExplorer';
import CodeEditor from './CodePreview';
import ComponentLibrary from './ComponentLibrary';
import LayoutTemplates, { LayoutTemplateData } from './LayoutTemplates';
import AjaxTemplates from './AjaxTemplates';
import { marked } from 'marked';
import { v4 as uuidv4 } from 'uuid';
import FloatingToolbar from './FloatingToolbar';
import JSZip from 'jszip';
import dbService from '../services/dbService';
import OrbMenu from './OrbMenu';
import InstructionsPanel from './InstructionsPanel';
import UrlLoaderModal from './UrlLoaderModal';
import SystemOperatorPanel from './SystemOperatorPanel';

const reactGuide = `# How to Preview a React Application

This sandbox can preview pre-built static web applications, including those created with frameworks like React. To do this, you need to upload the 'build' or 'dist' folder generated by your framework's build process.

## Step-by-Step Guide

1.  **Build Your ReactApp**: In your local React project terminal, run the build command:
    \`\`\`bash
    npm run build
    \`\`\`
    This will create a \`build\` (or \`dist\`) folder in your project directory. This folder contains all the static HTML, CSS, and JavaScript files needed to run your application.

2.  **Zip the Build Folder**: Compress the entire \`build\` folder into a single ZIP archive. For example, name it \`my-react-app.zip\`.

3.  **Upload the ZIP Archive**:
    *   In this sandbox, click the **Upload Files** icon in the File Explorer.
    *   Select the ZIP file you just created.
    *   The application will automatically unpack the ZIP archive, recreating the file and folder structure.

4.  **Set the Preview Root**:
    *   Find the newly uploaded folder (e.g., \`build\`) in the File Explorer.
    *   Hover over the folder name to reveal a **Play** icon.
    *   Click the **Play** icon to set this folder as the "Preview Root".

5.  **View Your Application**: The live preview panel on the right will now render your React application. You can browse and edit the uploaded files, and the preview will update accordingly.

**Note**: This sandbox does not run a live development server. It can only preview the static output from a build process. Any changes you make to the code will require you to manage the state and logic of the pre-built application.
`;

const componentDocs = `# Drag-and-Drop Component Library

This application features a visual, drag-and-drop editor to help you build your web page's structure quickly and intuitively.

## How to Use

1.  **Find the "Components" panel** on the left side of the screen, just below the File Explorer.
2.  **Click and drag** any component from the library.
3.  **Drop it** onto the live preview panel on the right.

The component will be automatically added to your \`index.html\` file, and you will see it appear instantly in the preview.

From there, you can:
*   Click directly on text elements in the preview to edit them. A floating toolbar will appear for styling.
*   Use the **Code Editor** to modify the component's attributes or add content.
*   Use the **AI Chat** to apply styles or add functionality (e.g., "Style the button to be blue" or "Make the image responsive").

## Available Components

Here is a list of the available components and their common uses:

*   **Heading**: For titles and section headers (\`<h1>\`, \`<h2>\`, etc.).
*   **Paragraph**: For all standard text content (\`<p>\`).
*   **Button**: For user actions and interactions (\`<button>\`).
*   **Image**: For embedding images (\`<img>\`). Remember to set the \`src\` attribute.
*   **Container**: A flexible container (\`<div>\`) used for grouping other elements and creating layouts. It's the primary building block for your page structure.
*   **Link**: For navigation to other pages or websites (\`<a>\`). Remember to set the \`href\` attribute.
*   **Input**: For creating form fields to accept user input (\`<input>\`).
*   **List**: For creating unordered lists (\`<ul>\`) with list items (\`<li>\`).
`;

const geminiCheatsheet = `# Gemini Agent Cheatsheet

Welcome to your AI-powered development sandbox! This cheatsheet will help you communicate effectively with the Gemini agent to build and modify your web projects.

## Guiding Principles

- **Be Specific**: The more detailed your request, the better the result. Instead of "make a button," try "create a primary button with a blue background, white text, and rounded corners."
- **One Task at aTime**: Give the agent one clear instruction at a time for more predictable outcomes.
- **Reference Files**: When you want to change a specific file, mention it by its full path (e.g., \`In /style.css, make all h1 elements red.\`).

## Common Commands

---

### Element Creation & Modification

- **Create an element**: \`Create a heading that says "Welcome"\`
- **Add attributes**: \`Add an id of "main-title" to the h1 element.\`
- **Nest elements**: \`Place the image inside a div with a class of "image-wrapper".\`
- **Add content**: \`Add three paragraphs of lorem ipsum text to the main content area.\`

---

### Styling (CSS & TailwindCSS)

- **Basic Styling**: \`Change the background color of the body to #f0f0f0.\`
- **Using Tailwind**: \`Use TailwindCSS to make the button have a shadow and scale up on hover.\`
- **Complex Styles**: \`In /style.css, add a class named "card" with a border, padding, and a box shadow.\`
- **Responsive Design**: \`Make the layout a single column on screens smaller than 600px.\`

---

### File System Operations

- **Create a file**: \`Create a new file named /components/card.js.\`
- **Write to a file**: \`In /components/card.js, add a function that logs "Card clicked" to the console.\`
- **Delete a file**: \`Delete the file /temp.css and remove its link from index.html.\`
- **Read a file**: \`What is in the /script.js file?\` (The agent already has this context, but it can be useful for clarification).

---

### JavaScript & Functionality

- **Add an event listener**: \`In script.js, add a click event listener to the button with id "submit-btn".\`
- **Write a function**: \`Write a JavaScript function called "calculateTotal" that takes price and quantity as arguments.\`
- **Fetch data**: \`Fetch data from the URL "https://api.example.com/users" and display the names in a list.\`
- **Update the DOM**: \`When the button is clicked, change the text of the paragraph with id "status" to "Submitted!".\`

---

### Putting It All Together: Example Workflow

1.  **You**: \`Create an index.html file, a style.css file, and a script.js file.\`
2.  **You**: \`In index.html, create a basic HTML structure with a header, main, and footer. Link the CSS and JS files.\`
3.  **You**: \`Add a button with the text "Get Data" to the main section.\`
4.  **You**: \`In style.css, style the button with a green background and white text.\`
5.  **You**: \`In script.js, when the button is clicked, fetch data from "https://jsonplaceholder.typicode.com/todos/1" and log the title to the console.\`

Happy building!
`;

const SUPERVISOR_INSTRUCTION_DEFAULT = `You are "Nexus", a hyper-competent AI web development assistant integrated into a live coding sandbox. Your purpose is to collaborate with the user to build and refine web projects by directly modifying the file system.

**Core Directives:**
1.  **Analyze Context**: Before responding, thoroughly analyze the user's prompt, the full chat history, and the complete state of all files provided in the context.
2.  **Act on Instructions**: Execute the user's request precisely. Your primary output is code modification.
3.  **Maintain File Integrity**: When modifying a file, you MUST provide the complete, updated content for that file. Do NOT use diffs, patches, or placeholders like "// ... existing code ...".
4.  **Adhere to Schema**: Your entire response MUST be a single, valid JSON object that conforms strictly to the provided JSON schema. No extra text, markdown, or commentary outside the JSON structure is permitted.

**JSON Response Structure:**
-   \`text\` (string, required): A brief, encouraging, and conversational confirmation of the action taken. Address the user directly.
-   \`explanation\` (string, required): A detailed breakdown of the changes. Use markdown for clarity (lists, bolding, code snippets). Explain *what* you changed and *why*. Offer a logical next step or a helpful tip to guide the user.
-   \`code\` (array of objects, optional): An array of file modifications. Each object MUST contain:
    -   \`path\` (string): The full, absolute path of the file being modified (e.g., "/style.css").
    -   \`content\` (string): The new, complete content of the file.

**Design & Development Principles:**
-   **Modern Practices**: Use modern HTML5, CSS3, and ES6+ JavaScript.
-   **Accessibility (A11y)**: Ensure generated HTML is semantic and accessible. Use ARIA attributes where necessary. Ensure sufficient color contrast.
-   **Responsiveness**: Use responsive design techniques (e.g., Flexbox, Grid, media queries) unless otherwise specified.
-   **Clarity & Readability**: Write clean, well-commented, and organized code.

The user's custom instructions will be provided separately. You must follow them in conjunction with these core directives.`;

const ORCHESTRATOR_INSTRUCTION_DEFAULT = `# Custom System Instructions

As the orchestrator, you guide the AI's high-level behavior.

**Current Goal:** Build a sleek, modern, and professional web portfolio.

**Design System:**
-   **Theme:** Dark mode is preferred. Use a color palette of dark grays/charcoals for backgrounds, with a vibrant accent color (like electric blue or neon green) for interactive elements.
-   **Typography:** Use a clean, sans-serif font for body text and a slightly bolder, more distinct font for headings.
-   **Layout:** Prioritize clean, spacious layouts. Use TailwindCSS for utility-first styling to ensure consistency and ease of modification.

**Behavioral Guidelines:**
-   **Proactive Suggestions:** When a user adds an element, suggest relevant styling or functionality. For example, after adding a form, suggest adding validation.
-   **Code Quality:** Explain any complex code you write with inline comments.
-   **Frameworks:** Stick to vanilla HTML, CSS, and JavaScript with TailwindCSS unless specifically asked to use another library.`;


const initialFileSystem: FileSystemState = {
  '/docs/react_upload_guide.md': reactGuide,
  '/docs/gemini_cheatsheet.md': geminiCheatsheet,
  '/instructions.md': ORCHESTRATOR_INSTRUCTION_DEFAULT,
  '/components.md': componentDocs,
  '/index.html': '<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>My Sandbox</title>\n  <link rel="stylesheet" href="/style.css">\n  <script src="https://cdn.tailwindcss.com"></script>\n</head>\n<body>\n  <h1 class="text-3xl font-bold text-center mt-8" data-editable-id="e7a78e4a-58f7-4a7c-b5f3-4d7a7d3e6e8e" contenteditable="true">Welcome to your Live Sandbox!</h1>\n  <p class="text-center" data-editable-id="b7a78e4a-58f7-4a7c-b5f3-4d7a7d3e6e8f" contenteditable="true">Drag components here or click to start building.</p>\n  <script src="/script.js"></script>\n</body>\n</html>',
  '/style.css': 'body { \n  font-family: sans-serif;\n  background-color: #111827; /* A default dark theme */\n  color: #E5E7EB; /* Default light text on dark background */\n}',
  '/script.js': '// JavaScript goes here',
};

const getLanguageFromPath = (path: string | null): 'html' | 'css' | 'javascript' | 'markdown' => {
    if (!path) return 'markdown'; // Default case
    const extension = path.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'js':
        case 'jsx':
        case 'ts':
        case 'tsx':
            return 'javascript';
        case 'html':
            return 'html';
        case 'css':
            return 'css';
        case 'md':
        case 'mdx':
            return 'markdown';
        default:
            return 'markdown'; // Treat unknown files as markdown/text
    }
};

const MarkdownPreview: React.FC<{ markdown: string }> = ({ markdown }) => {
    const [html, setHtml] = useState('');

    useEffect(() => {
        const renderMarkdown = async () => {
            if (!markdown) {
                setHtml('');
                return;
            }
            try {
                const parsedHtml = await marked.parse(markdown);
                setHtml(parsedHtml);
            } catch (error) {
                console.error("Error parsing markdown", error);
                const safeMarkdown = markdown.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                setHtml(`<pre>${safeMarkdown}</pre>`);
            }
        };
        renderMarkdown();
    }, [markdown]);

    return (
        <div className="prose p-6 overflow-y-auto h-full" dangerouslySetInnerHTML={{ __html: html }} />
    );
};


const OrchestratorPanel: React.FC = () => {
    const [fileSystem, setFileSystem] = useState<FileSystemState>(initialFileSystem);
    const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
    const [prompt, setPrompt] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [activeFile, setActiveFile] = useState<string | null>('/index.html');
    const [openFiles, setOpenFiles] = useState<string[]>(['/index.html', '/style.css', '/script.js']);
    const [previewRoot, setPreviewRoot] = useState<string | null>(null);
    const [leftPanelVisible, setLeftPanelVisible] = useState(true);
    const [rightPanelVisible, setRightPanelVisible] = useState(true);
    const [isAppMaximized, setIsAppMaximized] = useState(false);
    const [isEditorMaximized, setIsEditorMaximized] = useState(false);
    const [chatPanelHeight, setChatPanelHeight] = useState(300);
    const [hint, setHint] = useState<string>('');
    const [showHint, setShowHint] = useState(false);
    const [lastSaved, setLastSaved] = useState<Date | null>(null);
    const [isDraggingComponent, setIsDraggingComponent] = useState(false);

    // URL Loader State
    const [isUrlModalOpen, setIsUrlModalOpen] = useState(false);
    const [previewUrl, setPreviewUrl] = useState<string | null>(null);
    const [savedUrls, setSavedUrls] = useState<SavedUrl[]>([]);

    // Instructions Panel State
    const [isInstructionsPanelOpen, setIsInstructionsPanelOpen] = useState(false);
    const [supervisorInstruction, setSupervisorInstruction] = useState<string>(SUPERVISOR_INSTRUCTION_DEFAULT);
    const [orchestratorInstruction, setOrchestratorInstruction] = useState<string>(initialFileSystem['/instructions.md'] || ORCHESTRATOR_INSTRUCTION_DEFAULT);

    // Panel Resizing State
    const [leftPanelWidth, setLeftPanelWidth] = useState(280);
    const [rightPanelWidth, setRightPanelWidth] = useState(window.innerWidth * 0.4);
    const middlePanelRef = useRef<HTMLDivElement>(null);

    const chatContainerRef = useRef<HTMLDivElement>(null);
    const promptTextareaRef = useRef<HTMLTextAreaElement>(null);
    const iframeRef = useRef<HTMLIFrameElement>(null);
    const dropOverlayRef = useRef<HTMLDivElement>(null);
    
    // In-memory text editing state
    const [editingElement, setEditingElement] = useState<{ element: HTMLElement; id: string; file: string; originalHtml: string } | null>(null);
    const [editHistory, setEditHistory] = useState<{ past: string[]; future: string[] }>({ past: [], future: [] });
    const [toolbarPosition, setToolbarPosition] = useState<{ top: number; left: number } | null>(null);

    // ---- INLINE EDITING & FLOATING TOOLBAR ----
    const handleSaveEditing = useCallback(() => {
        if (!editingElement) return;

        const newHtml = editingElement.element.innerHTML;
        const { id, file, originalHtml } = editingElement;

        // Reset editing state regardless of changes
        setEditingElement(null);
        setToolbarPosition(null);

        // Don't update filesystem if nothing changed
        if (newHtml === originalHtml) return;
        
        const currentFileContent = fileSystem[file];
        if (typeof currentFileContent !== 'string') return;

        const parser = new DOMParser();
        const doc = parser.parseFromString(currentFileContent, 'text/html');
        const elementInDoc = doc.querySelector(`[data-editable-id="${id}"]`);

        if (elementInDoc) {
            elementInDoc.innerHTML = newHtml;
            const updatedFileContent = `<!DOCTYPE html>\n${doc.documentElement.outerHTML}`;
            
            setFileSystem(prev => ({
                ...prev,
                [file]: updatedFileContent
            }));
        }
    }, [editingElement, fileSystem]);

    useEffect(() => {
        const iframe = iframeRef.current;
        if (!iframe) return;

        let isMounted = true;

        const handleIframeLoad = () => {
            if (!isMounted) return;
            const iframeDoc = iframe.contentDocument;
            if (!iframeDoc) return;

            const handleFocus = (e: FocusEvent) => {
                const target = e.target as HTMLElement;
                if (target.isContentEditable) {
                    const id = target.dataset.editableId;
                    if (!id || (editingElement && editingElement.id === id)) return;
                    
                    if (editingElement) handleSaveEditing();

                    const currentHtml = target.innerHTML;
                    const previewPath = previewRoot ? `${previewRoot}/index.html` : '/index.html';

                    setEditingElement({
                        element: target,
                        id: id,
                        file: previewPath,
                        originalHtml: currentHtml,
                    });
                    setEditHistory({ past: [currentHtml], future: [] });

                    const rect = target.getBoundingClientRect();
                    const iframeRect = iframe.getBoundingClientRect();
                    setToolbarPosition({
                        top: iframeRect.top + rect.top,
                        left: iframeRect.left + rect.left + rect.width / 2,
                    });
                }
            };

            iframeDoc.body.addEventListener('focusin', handleFocus, true);
        };

        iframe.addEventListener('load', handleIframeLoad);
        
        return () => {
            isMounted = false;
            iframe.removeEventListener('load', handleIframeLoad);
        };
    }, [fileSystem, previewRoot, editingElement, handleSaveEditing]);

    useEffect(() => {
        const handleMouseDown = (e: MouseEvent) => {
            if (!editingElement) return;
            const target = e.target as Node;
            const toolbar = document.querySelector('[data-toolbar="true"]');
            
            if (toolbar && toolbar.contains(target)) return;
            if (editingElement.element.contains(target)) return;

            handleSaveEditing();
        };
        
        document.addEventListener('mousedown', handleMouseDown);
        return () => {
            document.removeEventListener('mousedown', handleMouseDown);
        };
    }, [editingElement, handleSaveEditing]);

    const handleToolbarCommand = useCallback((command: string, value?: string) => {
        if (!editingElement) return;
        const iframeDoc = iframeRef.current?.contentDocument;
        if (!iframeDoc) return;
        
        iframeDoc.execCommand(command, false, value);
        editingElement.element.focus();

        const newHtml = editingElement.element.innerHTML;
        setEditHistory(prev => ({
            past: [...prev.past, newHtml],
            future: []
        }));
    }, [editingElement]);

    const handleUndo = useCallback(() => {
        if (!editingElement || editHistory.past.length <= 1) return;
        
        setEditHistory(prev => {
            const newPast = [...prev.past];
            const lastState = newPast.pop()!;
            editingElement.element.innerHTML = newPast[newPast.length - 1];
            return { past: newPast, future: [lastState, ...prev.future] };
        });
        editingElement.element.focus();
    }, [editingElement, editHistory]);

    const handleRedo = useCallback(() => {
        if (!editingElement || editHistory.future.length === 0) return;

        setEditHistory(prev => {
            const newFuture = [...prev.future];
            const nextState = newFuture.shift()!;
            editingElement.element.innerHTML = nextState;
            return { past: [...prev.past, nextState], future: newFuture };
        });
        editingElement.element.focus();
    }, [editingElement, editHistory]);
    
    const handleRefineWithAI = useCallback(async () => {
        if (!editingElement) return;

        const instruction = window.prompt("How should I refine this element?", "make the text more engaging");
        if (!instruction) return;

        setIsLoading(true);
        try {
            const originalOuterHtml = editingElement.element.outerHTML;
            const refinedHtml = await refineCodeWithAgent(originalOuterHtml, 'html', instruction);
            
            const currentFileContent = fileSystem[editingElement.file];
            const parser = new DOMParser();
            const doc = parser.parseFromString(currentFileContent, 'text/html');
            const elementInDoc = doc.querySelector(`[data-editable-id="${editingElement.id}"]`);
            
            if (elementInDoc) {
                elementInDoc.outerHTML = refinedHtml;
                const updatedFileContent = `<!DOCTYPE html>\n${doc.documentElement.outerHTML}`;
                setFileSystem(prev => ({
                    ...prev,
                    [editingElement.file]: updatedFileContent
                }));
            }
        } catch (error) {
            console.error("Failed to refine with AI", error);
            alert("Sorry, an error occurred while refining the element.");
        } finally {
            setIsLoading(false);
            setEditingElement(null);
            setToolbarPosition(null);
        }
    }, [editingElement, fileSystem]);

    // ---- PANEL RESIZING ----
    useEffect(() => {
        const handleResize = () => {
            setRightPanelWidth(window.innerWidth * 0.4);
        };
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    const handleLeftResizeMouseDown = (e: React.MouseEvent) => {
        e.preventDefault();
        const startX = e.clientX;
        const startWidth = leftPanelWidth;

        const doDrag = (moveEvent: MouseEvent) => {
            const newWidth = startWidth + (moveEvent.clientX - startX);
            if (newWidth > 200 && newWidth < 500) {
                setLeftPanelWidth(newWidth);
            }
        };

        const stopDrag = () => {
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mouseup', stopDrag);
        };

        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
    };

    const handleMainResizeMouseDown = (e: React.MouseEvent) => {
        e.preventDefault();
        const startX = e.clientX;
        const startRightWidth = rightPanelWidth;
        const middlePanelCurrentWidth = middlePanelRef.current?.offsetWidth || 0;
        
        const doDrag = (moveEvent: MouseEvent) => {
            const dx = moveEvent.clientX - startX;
            const newRightWidth = startRightWidth - dx;

            const minWidth = 200;
            const totalWidth = middlePanelCurrentWidth + startRightWidth;
            
            if (newRightWidth > minWidth && (totalWidth - newRightWidth) > minWidth) {
                setRightPanelWidth(newRightWidth);
            }
        };

        const stopDrag = () => {
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mouseup', stopDrag);
        };

        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
    };

    // ---- DATA PERSISTENCE ----
    const saveStateToDb = useCallback(async () => {
        try {
            await dbService.initDB();
            await dbService.saveState({ 
                fileSystem, 
                chatHistory, 
                previewRoot, 
                openFiles, 
                activeFile,
                panelSizes: [leftPanelWidth, rightPanelWidth],
                chatPanelHeight,
                supervisorInstruction,
                orchestratorInstruction,
                savedUrls
            });
            setLastSaved(new Date());
        } catch (error) {
            console.error("Failed to save state:", error);
        }
    }, [fileSystem, chatHistory, previewRoot, openFiles, activeFile, chatPanelHeight, leftPanelWidth, rightPanelWidth, supervisorInstruction, orchestratorInstruction, savedUrls]);

    useEffect(() => {
        const loadState = async () => {
            try {
                await dbService.initDB();
                const savedState = await dbService.loadState();
                if (savedState) {
                    setFileSystem(savedState.fileSystem);
                    setChatHistory(savedState.chatHistory);
                    setPreviewRoot(savedState.previewRoot);
                    setOpenFiles(savedState.openFiles || ['/index.html']);
                    setActiveFile(savedState.activeFile || '/index.html');
                    setChatPanelHeight(savedState.chatPanelHeight || 300);
                    if (savedState.panelSizes) {
                        setLeftPanelWidth(savedState.panelSizes[0] || 280);
                        setRightPanelWidth(savedState.panelSizes[1] || window.innerWidth * 0.4);
                    }
                    setSupervisorInstruction(savedState.supervisorInstruction || SUPERVISOR_INSTRUCTION_DEFAULT);
                    setOrchestratorInstruction(savedState.orchestratorInstruction || ORCHESTRATOR_INSTRUCTION_DEFAULT);
                    setSavedUrls(savedState.savedUrls || []);
                }
            } catch (error) {
                console.error("Failed to load state:", error);
            }
        };
        loadState();
    }, []);

    // --- PREVIEW IFRAME LOGIC ---
    const updatePreview = useCallback(() => {
        const iframe = iframeRef.current;
        if (!iframe || previewUrl) return;

        const previewPath = previewRoot ? `${previewRoot}/index.html` : '/index.html';
        const htmlContent = fileSystem[previewPath];

        if (typeof htmlContent !== 'string') {
            iframe.srcdoc = `<html><body><h2 style="font-family: sans-serif; color: #f87171; text-align: center; margin-top: 2rem;">Error: Could not find <code>${previewPath}</code></h2><p style="font-family: sans-serif; text-align: center;">Please select a folder containing an index.html file as the preview root, or create an index.html file.</p></body></html>`;
            return;
        }

        const doc = new DOMParser().parseFromString(htmlContent, 'text/html');
        
        const DUMMY_BASE_URL = 'http://sandbox.local';
        const base = document.createElement('base');
        // Set the base href to correctly resolve relative paths within the preview context
        base.href = previewRoot ? `${DUMMY_BASE_URL}${previewRoot}/` : `${DUMMY_BASE_URL}/`;
        doc.head.prepend(base);

        const resolvePath = (url: string) => {
            try {
                const resolvedUrl = new URL(url, base.href);
                // If the origin is our dummy origin, it's a local file we should inline.
                if (resolvedUrl.origin === DUMMY_BASE_URL) {
                    return resolvedUrl.pathname;
                }
                // Otherwise, it's an external file (like a CDN link), so we leave it alone.
                return null;
            } catch (e) {
                // Invalid URL, ignore.
                return null;
            }
        };

        // Replace local CSS links with inline style tags
        const cssLinks = Array.from(doc.querySelectorAll<HTMLLinkElement>('link[rel="stylesheet"][href]'));
        cssLinks.forEach(link => {
            const path = resolvePath(link.getAttribute('href')!);
            if (path && fileSystem[path] !== undefined) {
                const style = doc.createElement('style');
                style.textContent = fileSystem[path];
                link.parentNode?.replaceChild(style, link);
            }
        });

        // Replace local JS script tags with inline script tags
        const scriptTags = Array.from(doc.querySelectorAll<HTMLScriptElement>('script[src]'));
        scriptTags.forEach(script => {
            const path = resolvePath(script.getAttribute('src')!);
            if (path && fileSystem[path] !== undefined) {
                const newScript = doc.createElement('script');
                // Preserve attributes like type='module'
                for (const attr of script.attributes) {
                    if (attr.name !== 'src') {
                        newScript.setAttribute(attr.name, attr.value);
                    }
                }
                newScript.textContent = fileSystem[path];
                script.parentNode?.replaceChild(newScript, script);
            }
        });
        
        // Add unique IDs to editable elements if they don't have one
        doc.querySelectorAll('[contenteditable="true"]').forEach(el => {
            if (!el.getAttribute('data-editable-id')) {
                el.setAttribute('data-editable-id', uuidv4());
            }
        });
        
        // The base tag was only needed for resolving paths, remove it before rendering.
        base.remove();
        iframe.srcdoc = doc.documentElement.outerHTML;

    }, [fileSystem, previewRoot, previewUrl]);


    useEffect(() => {
        if (!previewUrl) {
            const timer = setTimeout(updatePreview, 300);
            return () => clearTimeout(timer);
        }
    }, [updatePreview, previewUrl]);

    const handleLoadUrl = (url: string) => {
        setPreviewUrl(url);
        const iframe = iframeRef.current;
        if (iframe) {
            iframe.srcdoc = ''; // Clear srcdoc to make sure src is used
            iframe.src = url;
        }
    };

    const handleBackToSandbox = () => {
        setPreviewUrl(null);
        const iframe = iframeRef.current;
        if (iframe) {
            iframe.src = 'about:blank'; // Clear src
        }
    };

    const handleSaveUrl = (url: SavedUrl) => {
        setSavedUrls(prev => [...prev, url]);
    };

    const handleDeleteUrl = (id: string) => {
        setSavedUrls(prev => prev.filter(url => url.id !== id));
    };

    // ---- CHAT & AI LOGIC ----
    const handleSend = async () => {
        if (!prompt.trim() || isLoading) return;

        const newUserMessage: ChatMessage = { role: 'user', content: prompt };
        const newHistory = [...chatHistory, newUserMessage];
        setChatHistory(newHistory);
        setPrompt('');
        setIsLoading(true);
        setShowHint(false);

        try {
            const response = await chatWithAgent(newHistory, fileSystem, previewRoot, supervisorInstruction, orchestratorInstruction);
            
            const newModelMessage: ChatMessage = {
                role: 'model',
                content: response.text,
                explanation: response.explanation,
                code: response.code,
                suggestions: response.suggestions
            };
            setChatHistory(prev => [...prev, newModelMessage]);

            if (response.code) {
                handleApplyCode(response.code, true);
            }
        } catch (error) {
            console.error(error);
            const errorMessage: ChatMessage = {
                role: 'model',
                content: "Sorry, I encountered an error. Please check the console for details and ensure your API key is configured correctly.",
            };
            setChatHistory(prev => [...prev, errorMessage]);
        } finally {
            setIsLoading(false);
        }
    };

    const handleGenerateHint = useCallback(async () => {
      if (chatHistory.length > 0 && !isLoading) {
        const generatedHint = await getAiHint(chatHistory);
        if (generatedHint) {
          setHint(generatedHint);
          setShowHint(true);
        }
      }
    }, [chatHistory, isLoading]);
  
    useEffect(() => {
        const timer = setTimeout(() => {
            handleGenerateHint();
        }, 2000); // Generate hint after 2s of inactivity
        return () => clearTimeout(timer);
    }, [handleGenerateHint]);

    const handleSuggestionClick = (suggestion: string) => {
        setPrompt(suggestion);
        promptTextareaRef.current?.focus();
    };

    // Scroll chat to bottom
    useEffect(() => {
        if (chatContainerRef.current) {
            chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
        }
    }, [chatHistory]);

    // Resize prompt textarea
    useEffect(() => {
        const textarea = promptTextareaRef.current;
        if (textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = `${textarea.scrollHeight}px`;
        }
    }, [prompt]);

    const handleApplyCode = (codeChanges: { path: string, content: string }[], openNewFiles = false) => {
        setFileSystem(prevFs => {
            const newFs = { ...prevFs };
            codeChanges.forEach(change => {
                newFs[change.path] = change.content;
                if (change.path === '/instructions.md') {
                    setOrchestratorInstruction(change.content);
                }
            });
            return newFs;
        });

        if(openNewFiles) {
            const newFilesToOpen = codeChanges
                .map(c => c.path)
                .filter(path => !openFiles.includes(path));
            if (newFilesToOpen.length > 0) {
                setOpenFiles(prev => [...prev, ...newFilesToOpen]);
                // Set active file to the first new file
                setActiveFile(newFilesToOpen[0]);
            } else if (codeChanges.length > 0) {
                // If files were modified, make sure one is active
                setActiveFile(codeChanges[0].path);
            }
        }
    };
    
    // ---- FILE SYSTEM ----
    const handleFileSelect = (path: string) => {
        setActiveFile(path);
        if (!openFiles.includes(path)) {
            setOpenFiles(prev => [...prev, path]);
        }
    };

    const handleCloseFile = (path: string) => {
        const newOpenFiles = openFiles.filter(p => p !== path);
        setOpenFiles(newOpenFiles);
        if (activeFile === path) {
            setActiveFile(newOpenFiles.length > 0 ? newOpenFiles[0] : null);
        }
    };

    const handleFileContentChange = (path: string, content: string) => {
        setFileSystem(prev => ({ ...prev, [path]: content }));
        if (path === '/instructions.md') {
            setOrchestratorInstruction(content);
        }
    };

    const handleNewFile = (path: string) => {
        if (fileSystem[path] !== undefined) {
            alert("A file with this name already exists.");
            return;
        }
        setFileSystem(prev => ({ ...prev, [path]: '' }));
        handleFileSelect(path);
    };

    const handleNewFolder = (path: string) => {
        const placeholderPath = path.endsWith('/') ? `${path}.placeholder` : `${path}/.placeholder`;
        if (fileSystem[placeholderPath] !== undefined) {
            alert("A folder with this name already exists.");
            return;
        }
        setFileSystem(prev => ({ ...prev, [placeholderPath]: '' }));
    };

    const handleFileUpload = (files: FileList) => {
        for (const file of files) {
            if (file.name.endsWith('.zip')) {
                const dirName = window.prompt("Enter directory name to unpack ZIP:", file.name.replace(/\.zip$/, ''));
                if (!dirName) continue; // User cancelled

                const reader = new FileReader();
                reader.onload = async (e) => {
                    if (e.target?.result) {
                        setIsLoading(true);
                        try {
                            const zip = await JSZip.loadAsync(e.target.result as ArrayBuffer);
                            const newFiles: FileSystemState = {};
                            const rootDir = `/${dirName.replace(/^\/|\/$/g, '')}`; // Sanitize path

                            for (const relativePath in zip.files) {
                                const zipEntry = zip.files[relativePath];
                                const fullPath = `${rootDir}/${relativePath}`;
                                
                                if (zipEntry.dir) {
                                    // Ensure a placeholder is created for directories
                                    newFiles[`${fullPath.replace(/\/$/, '')}/.placeholder`] = '';
                                } else {
                                    newFiles[fullPath] = await zipEntry.async('string');
                                }
                            }

                            setFileSystem(prev => ({ ...prev, ...newFiles }));

                            const systemMessage: ChatMessage = {
                                role: 'system',
                                content: `Unpacked "${file.name}" into "${rootDir}". The files are now in the explorer. You can ask me to set this folder as the preview root or to inspect the code.`
                            };
                            setChatHistory(prev => [...prev, systemMessage]);

                        } catch (error) {
                            console.error("Error unpacking zip:", error);
                            const errorMessage = error instanceof Error ? error.message : String(error);
                            alert(`Failed to unpack zip file: ${errorMessage}`);
                        } finally {
                            setIsLoading(false);
                        }
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                const reader = new FileReader();
                reader.onload = (e) => {
                    setFileSystem(prev => ({ ...prev, [`/${file.name}`]: e.target?.result as string }));
                    handleFileSelect(`/${file.name}`);
                };
                reader.readAsText(file);
            }
        }
    };
    
    const handleDownloadProject = async () => {
        const zip = new JSZip();
        Object.entries(fileSystem).forEach(([path, content]) => {
            // Don't include placeholder files in the download
            if (!path.endsWith('.placeholder')) {
                // remove leading slash for cleaner zip structure
                zip.file(path.substring(1), content);
            }
        });
        const blob = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'sandbox-project.zip';
        link.click();
        URL.revokeObjectURL(link.href);
    };


    // ---- LAYOUT & DRAG-AND-DROP ----
    const addComponentToHtml = (component: DraggableComponent) => {
        const htmlPath = previewRoot ? `${previewRoot}/index.html` : '/index.html';
        const currentHtml = fileSystem[htmlPath];
        if (typeof currentHtml !== 'string') return;
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(currentHtml, 'text/html');

        // Smartly find a place to drop the component.
        const dropTarget = doc.querySelector('.container') || doc.querySelector('main') || doc.body;
        dropTarget.insertAdjacentHTML('beforeend', `\n${component.html}\n`);
        
        setFileSystem(prev => ({
            ...prev,
            [htmlPath]: doc.documentElement.outerHTML
        }));
    };

    const handleComponentClick = (component: DraggableComponent) => {
        addComponentToHtml(component);
    };

    const handleLayoutSelect = (layout: LayoutTemplateData) => {
        setFileSystem(prev => ({
            ...prev,
            '/index.html': layout.html,
            '/style.css': layout.css,
            '/script.js': layout.js || prev['/script.js'] || '// JavaScript goes here',
        }));
        if(!openFiles.includes('/index.html')) setOpenFiles(prev => [...prev, '/index.html']);
        if(!openFiles.includes('/style.css')) setOpenFiles(prev => [...prev, '/style.css']);
        if(layout.js && !openFiles.includes('/script.js')) setOpenFiles(prev => [...prev, '/script.js']);
        setActiveFile('/index.html');
    };

    const handleAjaxTemplateSelect = (template: AjaxTemplate) => {
        const templateFiles = template.files;
        const newFilePaths = Object.keys(templateFiles);
        setFileSystem(prev => ({
            ...prev,
            ...templateFiles
        }));
        
        const filesToOpen = ['/index.html', '/style.css', '/script.js'].filter(f => newFilePaths.includes(f));
        
        const allOpenFiles = [...new Set([...openFiles, ...filesToOpen])];
        setOpenFiles(allOpenFiles);

        setActiveFile(filesToOpen.includes('/index.html') ? '/index.html' : filesToOpen[0] || newFilePaths[0] || null);

        if (template.blockquote) {
            const systemMessage: ChatMessage = {
                role: 'system',
                content: template.blockquote
            };
            setChatHistory(prev => [...prev, systemMessage]);
        }
    };

    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDraggingComponent(false);
        
        const componentJson = e.dataTransfer.getData('application/vnd.live-dev-sandbox.component+json');
        if (componentJson) {
            const component: DraggableComponent = JSON.parse(componentJson);
            addComponentToHtml(component);
        }
    };

    const handleSaveInstructions = () => {
        setFileSystem(prevFs => ({
            ...prevFs,
            '/instructions.md': orchestratorInstruction,
        }));
        saveStateToDb(); // Persist changes
        setIsInstructionsPanelOpen(false);
    };

    // ---- SYSTEM OPERATOR ----
    const handleCreateContainer = (newFiles: FileSystemState, rootPath: string) => {
        setFileSystem(prev => ({ ...prev, ...newFiles }));
        setPreviewRoot(rootPath);
        // Open the main files of the new container
        const filesToOpen = Object.keys(newFiles).filter(path => path.endsWith('index.html') || path.endsWith('style.css') || path.endsWith('script.js') || path.endsWith('app.jsx') || path.endsWith('app.tsx'));
        setOpenFiles(prev => [...new Set([...prev, ...filesToOpen])]);
        setActiveFile(filesToOpen.find(f => f.endsWith('index.html')) || filesToOpen[0] || null);
    };

    const handleDeleteContainer = (containerPath: string) => {
        if (!window.confirm(`Are you sure you want to delete the container "${containerPath}"? This cannot be undone.`)) {
            return;
        }
        
        setFileSystem(prev => {
            const newFs = { ...prev };
            Object.keys(newFs).forEach(path => {
                if (path.startsWith(containerPath)) {
                    delete newFs[path];
                }
            });
            return newFs;
        });
        
        // Close any open files from that container
        const newOpenFiles = openFiles.filter(path => !path.startsWith(containerPath));
        setOpenFiles(newOpenFiles);
        if (activeFile?.startsWith(containerPath)) {
            setActiveFile(newOpenFiles.length > 0 ? newOpenFiles[0] : null);
        }
        if (previewRoot === containerPath) {
            setPreviewRoot(null);
        }
    };

    
    // ---- RENDER LOGIC ----
    const activeFileContent = activeFile ? fileSystem[activeFile] : null;
    const activeFileLang = getLanguageFromPath(activeFile);


    const renderEditor = () => {
        if (activeFile === null || activeFileContent === null || activeFileContent === undefined) {
            return <div className="flex items-center justify-center h-full text-gray-500">Select a file to begin editing.</div>
        }
        if (activeFileLang === 'markdown') {
            return <MarkdownPreview markdown={activeFileContent} />;
        }
        return (
            <CodeEditor
                key={activeFile}
                value={activeFileContent}
                language={activeFileLang}
                onChange={(content) => handleFileContentChange(activeFile, content)}
                onSave={saveStateToDb}
            />
        );
    };

    const handleChatResize = (e: React.MouseEvent) => {
        e.preventDefault();
        const startY = e.clientY;
        const startHeight = chatPanelHeight;
    
        const doDrag = (e: MouseEvent) => {
          const newHeight = startHeight - (e.clientY - startY);
          if (newHeight > 100 && newHeight < window.innerHeight - 200) {
            setChatPanelHeight(newHeight);
          }
        };
    
        const stopDrag = () => {
          document.removeEventListener('mousemove', doDrag);
          document.removeEventListener('mouseup', stopDrag);
        };
    
        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
    };

    return (
        <div className={`flex flex-col h-full overflow-hidden ${isAppMaximized ? 'fixed inset-0 z-[100] bg-[var(--dark-bg)]' : ''}`}>
             <OrbMenu onSave={saveStateToDb} lastSavedTimestamp={lastSaved} />
             <InstructionsPanel 
                isOpen={isInstructionsPanelOpen}
                onClose={() => setIsInstructionsPanelOpen(false)}
                supervisorInstruction={supervisorInstruction}
                setSupervisorInstruction={setSupervisorInstruction}
                orchestratorInstruction={orchestratorInstruction}
                setOrchestratorInstruction={setOrchestratorInstruction}
                onSave={handleSaveInstructions}
             />
             <UrlLoaderModal
                isOpen={isUrlModalOpen}
                onClose={() => setIsUrlModalOpen(false)}
                onLoadUrl={handleLoadUrl}
                savedUrls={savedUrls}
                onSaveUrl={handleSaveUrl}
                onDeleteUrl={handleDeleteUrl}
             />
             
            {/* Main Content Panels */}
            <div className="flex flex-grow overflow-hidden">
                {/* Left Panel */}
                {leftPanelVisible && !isAppMaximized && !isEditorMaximized && (
                    <div style={{ width: `${leftPanelWidth}px` }} className="bg-black/20 p-2 flex-shrink-0 flex flex-col gap-3 overflow-y-auto">
                        <CollapsibleSection title="File Explorer">
                            <FileExplorer
                                fileSystem={fileSystem}
                                activeFile={activeFile}
                                previewRoot={previewRoot}
                                onFileSelect={handleFileSelect}
                                onNewFile={handleNewFile}
                                onNewFolder={handleNewFolder}
                                onFileUpload={handleFileUpload}
                                onSetPreviewRoot={setPreviewRoot}
                                onDownloadProject={handleDownloadProject}
                            />
                        </CollapsibleSection>
                        <CollapsibleSection title="System Operator">
                           <SystemOperatorPanel
                                fileSystem={fileSystem}
                                onCreateContainer={handleCreateContainer}
                                onSetPreviewRoot={setPreviewRoot}
                                onDeleteContainer={handleDeleteContainer}
                           />
                        </CollapsibleSection>
                        <CollapsibleSection title="Components (Click or Drag)">
                            <ComponentLibrary onDragStart={() => setIsDraggingComponent(true)} onDragEnd={() => setIsDraggingComponent(false)} onComponentClick={handleComponentClick} />
                        </CollapsibleSection>
                        <CollapsibleSection title="Layouts">
                            <LayoutTemplates onLayoutSelect={handleLayoutSelect} />
                        </CollapsibleSection>
                         <CollapsibleSection title="AJAX Templates">
                            <AjaxTemplates onTemplateSelect={handleAjaxTemplateSelect} />
                        </CollapsibleSection>
                         <CollapsibleSection title="Docs & Cheatsheets">
                            <ul className="text-sm space-y-1">
                                <li><button onClick={() => handleFileSelect('/docs/gemini_cheatsheet.md')} className="text-[var(--neon-blue)] hover:underline">Gemini Cheatsheet</button></li>
                                <li><button onClick={() => handleFileSelect('/components.md')} className="text-[var(--neon-blue)] hover:underline">Component Guide</button></li>
                                <li><button onClick={() => handleFileSelect('/docs/react_upload_guide.md')} className="text-[var(--neon-blue)] hover:underline">React Upload Guide</button></li>
                                <li><button onClick={() => handleFileSelect('/instructions.md')} className="text-[var(--neon-blue)] hover:underline">Custom Instructions</button></li>
                            </ul>
                        </CollapsibleSection>
                    </div>
                )}
                
                {/* Left Resize Handle */}
                {leftPanelVisible && !isAppMaximized && !isEditorMaximized && (
                     <div
                        className="resize-handle"
                        onMouseDown={handleLeftResizeMouseDown}
                        title="Resize left panel"
                    />
                )}

                {/* Center Panel */}
                <div ref={middlePanelRef} className="flex-grow flex flex-col bg-[var(--dark-bg)] border-l border-r border-transparent overflow-hidden">
                    {/* Editor Tabs */}
                    <div className="flex-shrink-0 bg-black/20 border-b border-[var(--card-border)] flex items-center">
                        <button onClick={() => setLeftPanelVisible(!leftPanelVisible)} className="p-2.5 hover:bg-white/10 transition-colors">
                            <PanelLeftIcon className={`h-5 w-5 ${leftPanelVisible ? 'text-[var(--neon-pink)]' : ''}`} />
                        </button>
                        <div className="flex-grow flex items-center overflow-x-auto">
                           {openFiles.map(path => (
                                <button
                                    key={path}
                                    onClick={() => setActiveFile(path)}
                                    className={`flex items-center gap-2 p-2.5 text-sm border-r border-[var(--card-border)] whitespace-nowrap ${activeFile === path ? 'bg-[var(--dark-bg)] text-white' : 'text-gray-400 hover:bg-white/5'}`}
                                >
                                    <span>{path.split('/').pop()}</span>
                                    <span onClick={(e) => { e.stopPropagation(); handleCloseFile(path); }}>
                                        <XIcon className="h-4 w-4 rounded-full hover:bg-red-500/50" />
                                    </span>
                                </button>
                           ))}
                        </div>
                         <button
                            onClick={() => setIsInstructionsPanelOpen(true)}
                            title="Custom Instructions"
                            className="p-2.5 hover:bg-white/10 transition-colors border-l border-[var(--card-border)]"
                        >
                            <CogIcon className="h-5 w-5 text-gray-300 hover:text-[var(--neon-blue)]" />
                        </button>
                         <button
                            onClick={() => setIsEditorMaximized(!isEditorMaximized)}
                            title={isEditorMaximized ? "Restore Panels" : "Maximize Editor"}
                            className="p-2.5 hover:bg-white/10 transition-colors border-l border-[var(--card-border)]"
                        >
                            {isEditorMaximized ? <MinimizeIcon className="h-5 w-5 text-[var(--neon-pink)]" /> : <MaximizeIcon className="h-5 w-5" />}
                        </button>
                        <button onClick={() => setRightPanelVisible(!rightPanelVisible)} className="p-2.5 hover:bg-white/10 transition-colors border-l border-[var(--card-border)]">
                           <PanelRightIcon className={`h-5 w-5 ${rightPanelVisible ? 'text-[var(--neon-pink)]' : ''}`} />
                        </button>
                    </div>

                    {/* Code/Markdown Area & Chat */}
                    <div className="flex-grow flex flex-col overflow-hidden">
                        <div className="flex-grow overflow-hidden relative">
                           {renderEditor()}
                        </div>
                        
                        {/* Chat Panel */}
                        <div style={{ height: `${chatPanelHeight}px` }} className="flex-shrink-0 flex flex-col border-t-2 border-[var(--card-border)] bg-black/10">
                            <div 
                                onMouseDown={handleChatResize}
                                className="w-full h-1.5 bg-[var(--card-border)]/50 hover:bg-[var(--neon-purple)] cursor-row-resize transition-colors"
                                title="Resize chat panel"
                            />
                            
                            <div ref={chatContainerRef} className="flex-grow overflow-y-auto px-4">
                                {chatHistory.map((msg, i) => (
                                    <ChatMessageView key={i} message={msg} onApplyCode={handleApplyCode} onSuggestionClick={handleSuggestionClick} />
                                ))}
                                {isLoading && (
                                     <div className="flex items-start gap-3 my-4">
                                        <div className="flex-shrink-0 h-8 w-8 rounded-full flex items-center justify-center bg-[var(--neon-purple)] neon-glow-purple">
                                            <SpinnerIcon className="h-5 w-5 text-black animate-spin"/>
                                        </div>
                                         <div className="p-4 rounded-xl max-w-xl bg-black/30 border border-[var(--neon-purple)] text-[var(--text-color)]">
                                            <p className="text-sm italic">Thinking...</p>
                                        </div>
                                    </div>
                                )}
                            </div>

                             <div className="p-4 border-t border-[var(--card-border)] bg-black/20">
                                {showHint && hint && (
                                    <div className="mb-2 flex items-center justify-center text-sm">
                                        <button onClick={() => { setPrompt(hint); setShowHint(false); promptTextareaRef.current?.focus(); }} className="flex items-center gap-2 p-2 bg-black/30 hover:bg-black/50 border border-[var(--neon-blue)] rounded-full text-left transition-all group">
                                            <LightbulbIcon className="h-4 w-4 text-[var(--neon-blue)] flex-shrink-0" />
                                            <span className="text-gray-300 text-xs group-hover:text-white">{hint}</span>
                                        </button>
                                    </div>
                                )}
                                <div className="relative">
                                    <textarea
                                        ref={promptTextareaRef}
                                        value={prompt}
                                        onChange={(e) => setPrompt(e.target.value)}
                                        onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } }}
                                        placeholder="Ask the agent to make a change..."
                                        className="w-full bg-[var(--dark-bg)] border border-[var(--card-border)] rounded-lg p-4 pr-12 text-base placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-[var(--neon-purple)] focus:shadow-[0_0_8px_var(--neon-purple)] transition-all resize-none"
                                        rows={1}
                                        disabled={isLoading}
                                    />
                                    <button onClick={handleSend} disabled={isLoading || !prompt.trim()} className="absolute right-3 bottom-3 p-2 rounded-full bg-[var(--neon-purple)] disabled:bg-gray-600 text-black hover:brightness-125 transition-all">
                                        <ChevronUpIcon className="h-5 w-5" />
                                    </button>
                                </div>
                             </div>
                        </div>
                    </div>
                </div>
                
                {/* Main Resize Handle */}
                {rightPanelVisible && !isAppMaximized && !isEditorMaximized && (
                    <div
                        className="resize-handle"
                        onMouseDown={handleMainResizeMouseDown}
                        title="Resize panels"
                    />
                )}

                {/* Right Panel (Preview) */}
                {rightPanelVisible && !isEditorMaximized && (
                     <div style={{ width: `${rightPanelWidth}px`}} className="flex-shrink-0 flex flex-col bg-gray-100">
                        <div className="flex-shrink-0 bg-black border-b border-[var(--card-border)] flex items-center justify-between p-1.5">
                            <span className="text-sm font-semibold ml-2 text-gray-300">{previewUrl ? 'Live URL Preview' : 'Live Sandbox Preview'}</span>
                            <div className="flex items-center gap-2">
                                {previewUrl ? (
                                    <button onClick={handleBackToSandbox} title="Back to Sandbox" className="p-1.5 text-xs flex items-center gap-1 bg-white/10 hover:bg-white/20 rounded-md text-gray-300">
                                        <CodeIcon className="h-4 w-4" />
                                        <span>Sandbox</span>
                                    </button>
                                ) : (
                                    <button onClick={updatePreview} title="Refresh Preview" className="p-1.5 hover:bg-white/10 rounded-md text-gray-300">
                                        <RefreshCwIcon className="h-4 w-4" />
                                    </button>
                                )}
                                <button onClick={() => setIsUrlModalOpen(true)} title="Load from URL" className="p-1.5 hover:bg-white/10 rounded-md text-gray-300">
                                    <GlobeIcon className="h-4 w-4" />
                                </button>
                                <button onClick={() => setIsAppMaximized(!isAppMaximized)} title={isAppMaximized ? "Exit Fullscreen" : "Enter Fullscreen"} className="p-1.5 hover:bg-white/10 rounded-md text-gray-300">
                                    {isAppMaximized ? <MinimizeIcon className="h-4 w-4"/> : <MaximizeIcon className="h-4 w-4" />}
                                </button>
                            </div>
                        </div>
                        <div className="flex-grow relative bg-white">
                            <iframe
                                ref={iframeRef}
                                title="Live Preview"
                                className="w-full h-full border-none"
                                sandbox="allow-scripts allow-same-origin allow-forms allow-popups"
                                style={{ pointerEvents: isDraggingComponent ? 'none' : 'auto' }}
                            />
                            <div 
                                ref={dropOverlayRef} 
                                className="absolute inset-0 bg-green-500/20 border-4 border-dashed border-green-400 text-green-100 text-2xl font-bold items-center justify-center z-10 pointer-events-auto" 
                                style={{display: isDraggingComponent ? 'flex' : 'none'}}
                                onDrop={handleDrop}
                                onDragOver={(e) => { e.preventDefault(); e.stopPropagation(); }}
                            >
                                Drop to Add Component
                            </div>
                        </div>
                     </div>
                )}
            </div>
            {toolbarPosition && editingElement && (
                <FloatingToolbar 
                    position={toolbarPosition}
                    onCommand={handleToolbarCommand}
                    onUndo={handleUndo}
                    onRedo={handleRedo}
                    onSave={handleSaveEditing}
                    onRefine={handleRefineWithAI}
                    canUndo={editHistory.past.length > 1}
                    canRedo={editHistory.future.length > 0}
                />
            )}
        </div>
    );
};

export default OrchestratorPanel;